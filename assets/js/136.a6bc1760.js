(window.webpackJsonp=window.webpackJsonp||[]).push([[136],{466:function(t,a,e){"use strict";e.r(a);var s=e(42),r=Object(s.a)({},(function(){var t=this,a=t.$createElement,e=t._self._c||a;return e("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[e("p",[t._v("搞 Spring Boot 的小伙伴都知道，Spring Boot 中的配置文件有两种格式，properties 或者 yaml，一般情况下，两者可以随意使用，选择自己顺手的就行了，那么这两者完全一样吗？肯定不是啦！本文就来和大伙重点介绍下 yaml 配置，最后再来看看 yaml 和 properties 配置有何区别。")]),t._v(" "),e("h2",{attrs:{id:"狡兔三窟"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#狡兔三窟"}},[t._v("#")]),t._v(" 狡兔三窟")]),t._v(" "),e("p",[t._v("首先 application.yaml 在 Spring Boot 中可以写在四个不同的位置，分别是如下位置：")]),t._v(" "),e("ol",[e("li",[t._v("项目根目录下的 config 目录中")]),t._v(" "),e("li",[t._v("项目根目录下")]),t._v(" "),e("li",[t._v("classpath 下的 config 目录中")]),t._v(" "),e("li",[t._v("classpath 目录下")])]),t._v(" "),e("p",[t._v("四个位置中的 application.yaml 文件的优先级按照上面列出的顺序依次降低。即如果有同一个属性在四个文件中都出现了，以优先级高的为准。")]),t._v(" "),e("p",[t._v("那么 application.yaml 是不是必须叫 application.yaml 这个名字呢？当然不是必须的。开发者可以自己定义 yaml 名字，自己定义的话，需要在项目启动时指定配置文件的名字，像下面这样：")]),t._v(" "),e("p",[e("img",{attrs:{src:"http://www.javaboy.org/images/boot2/5-1.png",alt:""}})]),t._v(" "),e("p",[t._v("当然这是在 IntelliJ IDEA 中直接配置的，如果项目已经打成 jar 包了，则在项目启动时加入如下参数：")]),t._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[t._v("java -jar myproject.jar --spring.config.name=app\n")])])]),e("p",[t._v("这样配置之后，在项目启动时，就会按照上面所说的四个位置按顺序去查找一个名为 app.yaml 的文件。当然这四个位置也不是一成不变的，也可以自己定义，有两种方式，一个是使用 "),e("code",[t._v("spring.config.location")]),t._v(" 属性，另一个则是使用 "),e("code",[t._v("spring.config.additional-location")]),t._v(" 这个属性，在第一个属性中，表示自己重新定义配置文件的位置，项目启动时就按照定义的位置去查找配置文件，这种定义方式会覆盖掉默认的四个位置，也可以使用第二种方式，第二种方式则表示在四个位置的基础上，再添加几个位置，新添加的位置的优先级大于原本的位置。")]),t._v(" "),e("p",[t._v("配置方式如下：")]),t._v(" "),e("p",[e("img",{attrs:{src:"http://www.javaboy.org/images/boot2/5-2.png",alt:""}})]),t._v(" "),e("p",[t._v("这里要注意，配置文件位置时，值一定要以 "),e("code",[t._v("/")]),t._v(" 结尾。")]),t._v(" "),e("h2",{attrs:{id:"数组注入"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#数组注入"}},[t._v("#")]),t._v(" 数组注入")]),t._v(" "),e("p",[t._v("yaml 也支持数组注入，例如")]),t._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[t._v("my:\n  servers:\n\t- dev.example.com\n\t- another.example.com\n")])])]),e("p",[t._v("这段数据可以绑定到一个带 Bean 的数组中：")]),t._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[t._v('@ConfigurationProperties(prefix="my")\n@Component\npublic class Config {\n\n\tprivate List<String> servers = new ArrayList<String>();\n\n\tpublic List<String> getServers() {\n\t\treturn this.servers;\n\t}\n}\n')])])]),e("p",[t._v("项目启动后，配置中的数组会自动存储到 servers 集合中。当然，yaml 不仅可以存储这种简单数据，也可以在集合中存储对象。例如下面这种：")]),t._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[t._v("redis:\n  redisConfigs:\n    - host: 192.168.66.128\n      port: 6379\n    - host: 192.168.66.129\n      port: 6380\n")])])]),e("p",[t._v("这个可以被注入到如下类中：")]),t._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[t._v('@Component\n@ConfigurationProperties(prefix = "redis")\npublic class RedisCluster {\n    private List<SingleRedisConfig> redisConfigs;\n\t//省略getter/setter\n}\n')])])]),e("h2",{attrs:{id:"优缺点"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#优缺点"}},[t._v("#")]),t._v(" 优缺点")]),t._v(" "),e("p",[t._v("不同于 properties 文件的无序，yaml 配置是有序的，这一点在有些配置中是非常有用的，例如在 Spring Cloud Zuul 的配置中，当我们配置代理规则时，顺序就显得尤为重要了。当然 yaml 配置也不是万能的，例如，yaml 配置目前不支持 @PropertySource 注解。")])])}),[],!1,null,null,null);a.default=r.exports}}]);