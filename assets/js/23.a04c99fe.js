(window.webpackJsonp=window.webpackJsonp||[]).push([[23],{390:function(t,a,s){"use strict";s.r(a);var e=s(42),r=Object(e.a)({},(function(){var t=this,a=t.$createElement,s=t._self._c||a;return s("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[s("p",[t._v("前面我们介绍的所有操作都是在本地仓库完成的，本文我们主要来看看如何和远程仓库进行交互，为了方便起见，这里远程仓库我们选择 GitHub。")]),t._v(" "),s("p",[t._v("本文是 Git 系列的第五篇，了解前面的文章有助于更好的理解本文：")]),t._v(" "),s("hr"),t._v(" "),s("p",[t._v("1."),s("a",{attrs:{href:"https://mp.weixin.qq.com/s/3RheAJ9LYKK5BnVr331h5A",target:"_blank",rel:"noopener noreferrer"}},[t._v("Git 概述"),s("OutboundLink")],1),s("br"),t._v("\n2."),s("a",{attrs:{href:"https://mp.weixin.qq.com/s/S1T4wy3srmLvXgIjvpVEwg",target:"_blank",rel:"noopener noreferrer"}},[t._v("Git 基本操作"),s("OutboundLink")],1),s("br"),t._v("\n3."),s("a",{attrs:{href:"https://mp.weixin.qq.com/s/WiLnRQfDVITHMYzGl9pAzQ",target:"_blank",rel:"noopener noreferrer"}},[t._v("Git 中的各种后悔药"),s("OutboundLink")],1),s("br"),t._v("\n4."),s("a",{attrs:{href:"https://mp.weixin.qq.com/s/9OZY7x9DSyRO7T56TyDJ8Q",target:"_blank",rel:"noopener noreferrer"}},[t._v("Git 分支管理"),s("OutboundLink")],1)]),t._v(" "),s("hr"),t._v(" "),s("h2",{attrs:{id:"配置-ssh-key"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#配置-ssh-key"}},[t._v("#")]),t._v(" 配置 SSH KEY")]),t._v(" "),s("p",[t._v("SSH KEY 的配置不是必须的，不配置的话我们就只能使用 HTTPS 协议，这样每次提交时要输入用户名密码，略麻烦，所以还是配置一下。配置 SSH KEY 的原理很简单，采用非对称加密方式生成公钥和私钥，公钥告诉 GitHub ，私钥留在自己电脑上(私钥不可泄露)，当我们向 GitHub 上提交数据时，GitHub 会用我们留给它的公钥加密一段消息返回给我们的电脑，如果我们能够用私钥解密成功，说明是合法的用户，这样就避免我们输入用户名密码了。大致的原理就是这样，现在很多免登录的系统都采用了这种方式，比如 Hadoop 免登录配置也是这样。那我们就来看看这个 SSH　KEY 要怎么生成。")]),t._v(" "),s("h3",{attrs:{id:"_1-查看本地是否已有-sshkey"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_1-查看本地是否已有-sshkey"}},[t._v("#")]),t._v(" 1.查看本地是否已有 SSHKEY")]),t._v(" "),s("p",[t._v("查看当前用户目录下是否有 .ssh 文件，如下：")]),t._v(" "),s("p",[s("img",{attrs:{src:"http://www.javaboy.org/images/git/p202.png",alt:"p202"}})]),t._v(" "),s("p",[t._v("如果查看之后有结果，则直接跳转到第四步，什么都没有就继续生成。")]),t._v(" "),s("h3",{attrs:{id:"_2-生成-ssh-指纹"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_2-生成-ssh-指纹"}},[t._v("#")]),t._v(" 2.生成 SSH 指纹")]),t._v(" "),s("p",[t._v("生成 SSH 指纹的命令很简单，如下：")]),t._v(" "),s("div",{staticClass:"language- extra-class"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[t._v('ssh-keygen -t rsa -b 4096 -C "你的邮箱地址"\n')])])]),s("p",[t._v("注意邮箱地址要替换。")]),t._v(" "),s("h3",{attrs:{id:"_3-添加-ssh-到-ssh-agent-中"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_3-添加-ssh-到-ssh-agent-中"}},[t._v("#")]),t._v(" 3.添加 ssh 到 ssh-agent 中")]),t._v(" "),s("p",[t._v("执行如下命令即可：")]),t._v(" "),s("div",{staticClass:"language- extra-class"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[t._v('eval "$(ssh-agent -s)"\n')])])]),s("p",[t._v("OK，做好这一切之后，我们当前用户目录下已经有了一个名为 .ssh 的隐藏文件夹了，打开这个目录，会发现有一个名为 id_rsa.pub 的文件，这就是我们一会要使用的公钥文件。")]),t._v(" "),s("h3",{attrs:{id:"_4-将公钥告诉-github"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_4-将公钥告诉-github"}},[t._v("#")]),t._v(" 4.将公钥告诉 GitHub")]),t._v(" "),s("p",[t._v("登录 GitHub ，点击右上角的向下的箭头，选择 Settings ，在新打开的页面中左边侧栏选择 "),s("strong",[t._v("SSH and GPG keys")]),t._v(" ，如下：")]),t._v(" "),s("p",[s("img",{attrs:{src:"http://www.javaboy.org/images/git/p203.png",alt:"p203"}})]),t._v(" "),s("p",[t._v("完了之后点击最下面的 Add SSH key 按钮即可，如此之后，我们的 SSH KEY 就配置成功了。")]),t._v(" "),s("h2",{attrs:{id:"创建远程仓库"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#创建远程仓库"}},[t._v("#")]),t._v(" 创建远程仓库")]),t._v(" "),s("p",[t._v("接下来我们在 GitHub 上创建一个仓库，登录成功之后，直接点击右上角绿色的 New repository 按钮，如下：")]),t._v(" "),s("p",[s("img",{attrs:{src:"http://www.javaboy.org/images/git/p204.png",alt:"p204"}})]),t._v(" "),s("p",[t._v("其实这里我们只需要填一个版本仓库的名字，我填了 test，填好之后，点击 Create repository 就 OK 了。")]),t._v(" "),s("h2",{attrs:{id:"关联远程仓库"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#关联远程仓库"}},[t._v("#")]),t._v(" 关联远程仓库")]),t._v(" "),s("p",[t._v("创建成功之后，我们会看到仓库的地址，如下： "),s("code",[t._v("git@github.com:lenve/test.git")]),t._v(" ，然后我需要将我们之前的本地仓库和这个远程仓库进行关联，使用 git remote add 命令，如下：")]),t._v(" "),s("div",{staticClass:"language- extra-class"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[t._v("$ git remote add origin git@github.com:lenve/test.git\n")])])]),s("p",[t._v("在这条命令中，git 会自动将远程仓库的名字设置为 origin ，方便我们的后续操作。")]),t._v(" "),s("h2",{attrs:{id:"推送到远程仓库"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#推送到远程仓库"}},[t._v("#")]),t._v(" 推送到远程仓库")]),t._v(" "),s("h3",{attrs:{id:"推送到master分支"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#推送到master分支"}},[t._v("#")]),t._v(" 推送到master分支")]),t._v(" "),s("p",[t._v("假设我想将本地 master 分支上的内容推送到远程 master 分支上，方式如下：")]),t._v(" "),s("div",{staticClass:"language- extra-class"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[t._v("$ git push -u origin master\n")])])]),s("p",[t._v("-u参数可以在推送的同时，将 origin 仓库的 master 分支设置为本地仓库当前分支的 upstream（上游）。添加了这个参数，将来运行 git pull 命令从远程仓库获取内容时，本地仓库的这个分支就可以直接从 origin 的 master 分支获取内容，省去了另外添加参数的麻烦。这个参数也只用在第一次 push 时加上，以后直接运行 git push 命令即可。")]),t._v(" "),s("h3",{attrs:{id:"推送到其他分支"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#推送到其他分支"}},[t._v("#")]),t._v(" 推送到其他分支")]),t._v(" "),s("p",[t._v("如果想推送到其他分支，还是这条命令，修改一下分支的名字即可，比如我也想把我的 fa 分支推送到远程仓库中，执行如下命令：")]),t._v(" "),s("div",{staticClass:"language- extra-class"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[t._v("$ git checkout fa\n$ git push -u origin fa\n")])])]),s("p",[t._v("先切换到 fa 分支，然后执行 git push 命令，参数含义和之前的一样，这里我们创建的远程仓库的分支名也为 fa（当然我们可以取任何名字，但是为了不混淆，最好取一致的名字）。这两条命令执行成功之后，此时在网页中我们就可以看到已经有多个分支了，如下：")]),t._v(" "),s("p",[s("img",{attrs:{src:"http://www.javaboy.org/images/git/p205.png",alt:"p205"}})]),t._v(" "),s("h2",{attrs:{id:"从远程仓库获取"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#从远程仓库获取"}},[t._v("#")]),t._v(" 从远程仓库获取")]),t._v(" "),s("h3",{attrs:{id:"首次获取"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#首次获取"}},[t._v("#")]),t._v(" 首次获取")]),t._v(" "),s("p",[t._v("刚刚是我们向远程仓库提交数据，有提交当然就有获取，我们可以通过 git clone 命令克隆一个远程仓库到本地，方式也简单，在本地创建一个空文件夹，执行如下命令：")]),t._v(" "),s("div",{staticClass:"language- extra-class"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[t._v("$ git clone git@github.com:lenve/test.git\n")])])]),s("p",[t._v("表示克隆文件到本地仓库。此时克隆的远程仓库的 master 分支到本地仓库，我们可以通过 "),s("code",[t._v("git branch -a")]),t._v(" 来查看本地仓库和远程仓库的信息，-a 参数可以同时显示本地仓库和远程仓库的信息，如下：")]),t._v(" "),s("p",[s("img",{attrs:{src:"http://www.javaboy.org/images/git/p206.png",alt:"p206"}})]),t._v(" "),s("p",[t._v("我们看到远程仓库中已经有了 fa 分支了，如果我们想把 fa 分支也克隆下来，执行如下命令：")]),t._v(" "),s("div",{staticClass:"language- extra-class"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[t._v("$ git checkout -b fa origin/fa\n")])])]),s("p",[t._v("表示根据远程仓库的 fa 分支创建一个本地仓库的 fa 分支，创建完成之后进行切换，也可以通过如下命令只创建不切换：")]),t._v(" "),s("div",{staticClass:"language- extra-class"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[t._v("$ git branch fa origin/fa\n")])])]),s("p",[t._v("此时我在 fa 分支下修改 git01.txt 文件并提交，如下：")]),t._v(" "),s("p",[s("img",{attrs:{src:"http://www.javaboy.org/images/git/p207.png",alt:"p207"}})]),t._v(" "),s("p",[t._v("注意由于 fa 分支就是从远程仓库克隆下来的，所以这里可以不添加 -u 参数。")]),t._v(" "),s("h3",{attrs:{id:"从远程仓库更新"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#从远程仓库更新"}},[t._v("#")]),t._v(" 从远程仓库更新")]),t._v(" "),s("p",[t._v("此时我们回到第一次最早的那个 test 本地仓库中，那个 test 仓库的 fa 分支现在和远程仓库不一致了，我们可以通过 git pull 命令来更新，如下：")]),t._v(" "),s("p",[s("img",{attrs:{src:"http://www.javaboy.org/images/git/p208.png",alt:"p208"}})]),t._v(" "),s("p",[t._v("Ok，关联远程仓库我们先说这么多。有问题欢迎留言讨论。")]),t._v(" "),s("p",[t._v("参考资料：")]),t._v(" "),s("p",[t._v("1.《GitHub入门与实践》"),s("br"),t._v("\n2.《Pro Git》")])])}),[],!1,null,null,null);a.default=r.exports}}]);