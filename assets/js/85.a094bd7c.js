(window.webpackJsonp=window.webpackJsonp||[]).push([[85],{435:function(t,e,a){"use strict";a.r(e);var r=a(42),n=Object(r.a)({},(function(){var t=this,e=t.$createElement,a=t._self._c||e;return a("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[a("p",[t._v("上篇文章我们对 STRING 数据类型中一些基本的命令进行了介绍，但是没有涉及到 BIT 相关的命令，本文我们就来看看几个和 BIT 相关的命令。")]),t._v(" "),a("p",[t._v("本文是 Redis 系列的第四篇文章，了解前面的文章有助于更好的理解本文：")]),t._v(" "),a("hr"),t._v(" "),a("p",[t._v("1."),a("a",{attrs:{href:"https://mp.weixin.qq.com/s/NCm3zNGIDVMnlykeOiaH7Q",target:"_blank",rel:"noopener noreferrer"}},[t._v("Linux 上安装 Redis"),a("OutboundLink")],1),a("br"),t._v("\n2."),a("a",{attrs:{href:"http://mp.weixin.qq.com/s/jNSN8YO4jZbyjKR5C4in_w",target:"_blank",rel:"noopener noreferrer"}},[t._v("Redis 中的五种数据类型简介"),a("OutboundLink")],1),a("br"),t._v("\n3."),a("a",{attrs:{href:"https://mp.weixin.qq.com/s/Svvgwo_a92vNdCSazbzKRQ",target:"_blank",rel:"noopener noreferrer"}},[t._v("Redis 字符串 (STRING) 介绍"),a("OutboundLink")],1)]),t._v(" "),a("hr"),t._v(" "),a("p",[t._v("BIT 相关的命令是指 BITCOUNT/BITFIELD/BITOP/BITPOS/SETBIT/GETBIT 几个命令，灵活使用这几个命令，可以给我们的项目带来很多惊喜。")]),t._v(" "),a("h2",{attrs:{id:"准备知识"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#准备知识"}},[t._v("#")]),t._v(" 准备知识")]),t._v(" "),a("p",[t._v("在学习这几个命令之前，我们得先了解下 redis 中字符串的存储方式，redis 中的字符串都是以二进制的方式进行存储的，比如说我执行如下命令：")]),t._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[t._v("127.0.0.1:6379> SET k1 a\nOK\n")])])]),a("p",[t._v("a 对应的 ASCII 码是 97 ，转换为二进制数据是 01100001 ，我们 BIT 相关命令都是对这个二进制数据进行操作。请继续往下看。")]),t._v(" "),a("h3",{attrs:{id:"getbit"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#getbit"}},[t._v("#")]),t._v(" GETBIT")]),t._v(" "),a("p",[t._v("GETBIT 命令可以返回 key 对应的 value 在 offset 处的 bit 值，以上文提到的 k1 为例， a 对应的二进制数据是 01100001 ，所以当 offset 为 0 时，对应的 bit 值为 0 ； offset 为 1 时，对应的 bit 值为 1 ； offset 为 2 时，对应的 bit 值为 1 ；offset 为 3 时，对应的 bit 值为 0，依此类推....，如下：")]),t._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[t._v("127.0.0.1:6379> GETBIT k1 0\n(integer) 0\n127.0.0.1:6379> GETBIT k1 1\n(integer) 1\n127.0.0.1:6379> GETBIT k1 2\n(integer) 1\n127.0.0.1:6379> GETBIT k1 3\n(integer) 0\n127.0.0.1:6379> GETBIT k1 4\n(integer) 0\n127.0.0.1:6379> GETBIT k1 5\n(integer) 0\n127.0.0.1:6379> GETBIT k1 6\n(integer) 0\n127.0.0.1:6379> GETBIT k1 7\n(integer) 1\n")])])]),a("h3",{attrs:{id:"setbit"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#setbit"}},[t._v("#")]),t._v(" SETBIT")]),t._v(" "),a("p",[t._v("SETBIT 可以用来修改二进制数据，比如 a 对应的 ASCII 码为 97，c 对应的 ASCII 码为 99，97 转为二进制是 01100001 ，99 转为二进制是 01100011 ，两个的差异在于第六位一个是 0 一个是 1 ，通过 SETBIT 命令，我们可以将 k1 的第六位的 0 改为 1 （第六位是从 0 开始算），如下：")]),t._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[t._v('127.0.0.1:6379> SETBIT k1 6 1\n(integer) 0\n127.0.0.1:6379> GET k1\n"c"\n')])])]),a("p",[t._v("此时，k1 中存储的字符也就变为了 c。SETBIT 在执行时所返回的数字，表示该位上原本的 bit 值。")]),t._v(" "),a("h3",{attrs:{id:"bitcount"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#bitcount"}},[t._v("#")]),t._v(" BITCOUNT")]),t._v(" "),a("p",[t._v("BITCOUNT 可以用来统计这个二进制数据中 1 的个数，如下：")]),t._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[t._v("127.0.0.1:6379> BITCOUNT k1\n(integer) 4\n")])])]),a("p",[t._v("关于 BITCOUNT，redis 官网上有一个非常有意思的案例：用户上线次数统计。节选部分原文如下：")]),t._v(" "),a("blockquote",[a("p",[t._v("举个例子，如果今天是网站上线的第 100 天，而用户 peter 在今天阅览过网站，那么执行命令 SETBIT peter 100 1 ；如果明天 peter 也继续阅览网站，那么执行命令 SETBIT peter 101 1 ，以此类推。当要计算 peter 总共以来的上线次数时，就使用 BITCOUNT 命令：执行 BITCOUNT peter ，得出的结果就是 peter 上线的总天数。")])]),t._v(" "),a("p",[t._v("这种统计方式最大的好处就是节省空间并且运算速度快。每天占用一个 bit，一年也就 365 个 bit，10 年也就 10*365 个 bit ，也就是 456 个字节，对于这么大的数据，bit 的操作速度非常快。")]),t._v(" "),a("h3",{attrs:{id:"bitop"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#bitop"}},[t._v("#")]),t._v(" BITOP")]),t._v(" "),a("p",[t._v("BITOP 可以对一个或者多个二进制位串执行并 (AND)、或 (OR)、异或 (XOR) 以及非 (NOT) 运算，如下：a 对应的 ASCII 码转为二进制是 01100001 ，c 对应的二进制位串是 01100011 。对这两个二进制位串分别执行 AND\\OR\\XOR 的结果如下：")]),t._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[t._v('127.0.0.1:6379> set k1 a\nOK\n127.0.0.1:6379> set k2 c\nOK\n127.0.0.1:6379> BITOP and k3 k1 k2\n(integer) 1\n127.0.0.1:6379> get k3\n"a"\n127.0.0.1:6379> BITOP or k3 k1 k2\n(integer) 1\n127.0.0.1:6379> get k3\n"c"\n127.0.0.1:6379> BITOP xor k3 k1 k2\n(integer) 1\n127.0.0.1:6379> get k3\n"\\x02"\n')])])]),a("p",[t._v("另外，BITOP 也可以执行 NOT 运算，但是注意参数个数，如下：")]),t._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[t._v("127.0.0.1:6379> BITOP not k3 k4\n(integer) 1\n")])])]),a("p",[t._v("这里会对 k4 的二进制位串取反，将取反结果交给 k3 。")]),t._v(" "),a("h3",{attrs:{id:"bitpos"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#bitpos"}},[t._v("#")]),t._v(" BITPOS")]),t._v(" "),a("p",[t._v("BITPOS 用来获取二进制位串中第一个 1 或者 0 的位置，如下：")]),t._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[t._v("127.0.0.1:6379> set k1 a\nOK\n127.0.0.1:6379> BITPOS k1 1\n(integer) 1\n127.0.0.1:6379> BITPOS k1 0\n(integer) 0\n")])])]),a("p",[t._v("也可以在后面设置一个范围，不过后面的范围是字节的范围，而不是二进制位串的范围。")]),t._v(" "),a("p",[t._v("OK,STRING 中 BIT 相关的命令我们就介绍这么多，更多命令小伙伴们可以参考"),a("a",{attrs:{href:"http://www.redis.cn/commands.html",target:"_blank",rel:"noopener noreferrer"}},[t._v("官方文档"),a("OutboundLink")],1),t._v("。小伙伴在看官方文档时，有什么问题欢迎留言讨论。")])])}),[],!1,null,null,null);e.default=n.exports}}]);