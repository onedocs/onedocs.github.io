(window.webpackJsonp=window.webpackJsonp||[]).push([[9],{522:function(a,t,r){"use strict";r.r(t);var v=r(42),e=Object(v.a)({},(function(){var a=this,t=a.$createElement,r=a._self._c||t;return r("ContentSlotsDistributor",{attrs:{"slot-key":a.$parent.slotKey}},[r("p",[a._v("docker 中的容器就是一个轻量级的虚拟机，是镜像运行起来的一个状态，本文就先来看看容器的基本操作。")]),a._v(" "),r("p",[a._v("镜像就像是一个安装程序，而容器则是程序运行时的一个状态。")]),a._v(" "),r("h2",{attrs:{id:"查看容器"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#查看容器"}},[a._v("#")]),a._v(" 查看容器")]),a._v(" "),r("h3",{attrs:{id:"查看容器-2"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#查看容器-2"}},[a._v("#")]),a._v(" 查看容器")]),a._v(" "),r("p",[a._v("启动 docker 后，使用 "),r("code",[a._v("docker ps")]),a._v(" 命令可以查看当前正在运行的容器：")]),a._v(" "),r("p",[r("img",{attrs:{src:"http://www.javaboy.org/images/docker/2-1.png",alt:"2-1"}})]),a._v(" "),r("h3",{attrs:{id:"查看所有容器"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#查看所有容器"}},[a._v("#")]),a._v(" 查看所有容器")]),a._v(" "),r("p",[a._v("\b上面这条命令是查看当前正在运行的容器，如果需要查看所有容器，则可以通过 "),r("code",[a._v("docker ps -a")]),a._v(" 命令查看：")]),a._v(" "),r("p",[r("img",{attrs:{src:"http://www.javaboy.org/images/docker/2-2.png",alt:"2-2"}})]),a._v(" "),r("p",[a._v("在查看容器时，涉及到几个查看参数，含义分别如下：")]),a._v(" "),r("ul",[r("li",[a._v("CONTAINER ID:CONTAINER ID是指容器的id，是一个唯一标识符,这是一个64位的十六进制整数，在不会混淆的情况下可以只采用id的前几位进行\b标识一个容器。")]),a._v(" "),r("li",[a._v("IMAGE:IMAGE表示创建容器时使用的镜像。")]),a._v(" "),r("li",[a._v("COMMAND:COMMAND表示容器最后运行的命令。")]),a._v(" "),r("li",[a._v("CREATED:创建容器的时间。")]),a._v(" "),r("li",[a._v("STATUS:容器的状态，这里可能显示一个容器启动时间，也能显示容器关闭时间。具体显示哪个要看容器当前的状态。")]),a._v(" "),r("li",[a._v("PORTS:容器对外开放的端口。")]),a._v(" "),r("li",[a._v("NAMES:容器的名字，如果不设置，会有一个默认的名字。")])]),a._v(" "),r("h3",{attrs:{id:"查看最新创建的容器"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#查看最新创建的容器"}},[a._v("#")]),a._v(" 查看最新创建的容器")]),a._v(" "),r("p",[a._v("使用 "),r("code",[a._v("docker ps -l")]),a._v(" 可以查看最近创建的容器，如下：")]),a._v(" "),r("p",[r("img",{attrs:{src:"http://www.javaboy.org/images/docker/2-3.png",alt:"2-3"}})]),a._v(" "),r("h3",{attrs:{id:"查看最新创建的n个容器"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#查看最新创建的n个容器"}},[a._v("#")]),a._v(" 查看最新创建的n个容器")]),a._v(" "),r("p",[a._v("可以使用 "),r("code",[a._v("docker ps -n=XXX")]),a._v(" 来查看最新创建的n个容器，如下：")]),a._v(" "),r("p",[r("img",{attrs:{src:"http://www.javaboy.org/images/docker/2-4.png",alt:"2-4"}})]),a._v(" "),r("h2",{attrs:{id:"创建容器"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#创建容器"}},[a._v("#")]),a._v(" 创建容器")]),a._v(" "),r("p",[a._v("创建容器整体上来说有两种不同的方式，可以先创建，再启动，也可以连创建带启动一步到位，无论是那种方式，流程都是相似的，当执行一个创建命令之后，docker 首先会去本地路径下查找是否有相应的镜像，如果没有，就去 docker hub 上\b搜索\b，如果搜索到了，则下载下来，然后利用该镜像\b创建一个容器并启动。容器的文件系统是\b在只读的镜像文件上添加一层可读写的文件层，这样可以使在不改变镜像的情况下，只记录改变的数据。下面对这两种方式分别予以介绍。")]),a._v(" "),r("h3",{attrs:{id:"容器创建"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#容器创建"}},[a._v("#")]),a._v(" 容器创建")]),a._v(" "),r("p",[a._v("开发者可以首先使用\b "),r("code",[a._v("docker create")]),a._v(" 命令\b创建一个容器，这个时候创建出来的容器是处于停止状态，\b没有运行，\b例如要创建一个 nginx 容器，\b创建命令如下：")]),a._v(" "),r("div",{staticClass:"language- extra-class"},[r("pre",{pre:!0,attrs:{class:"language-text"}},[r("code",[a._v("docker create nginx\n")])])]),r("p",[a._v("创建成功后，可以查看容器是否创建成功：")]),a._v(" "),r("p",[r("img",{attrs:{src:"http://www.javaboy.org/images/docker/2-5.png",alt:"2-5"}})]),a._v(" "),r("p",[a._v("此时创建的容器并未运行，处于停止状态，\b容器的 name 是随机生成的，开发者也可以在创建容器时指定 name ，如下：")]),a._v(" "),r("div",{staticClass:"language- extra-class"},[r("pre",{pre:!0,attrs:{class:"language-text"}},[r("code",[a._v("docker create --name=nginx nginx\n")])])]),r("p",[a._v("运行结果如下：")]),a._v(" "),r("p",[r("img",{attrs:{src:"http://www.javaboy.org/images/docker/2-6.png",alt:"2-6"}})]),a._v(" "),r("p",[a._v("此时的 name 属性就不是随机生成的，而是用户指定的 name。")]),a._v(" "),r("p",[a._v("这种方式只是单纯的创建了一个用户，并未启动。")]),a._v(" "),r("h3",{attrs:{id:"容器创建-启动"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#容器创建-启动"}},[a._v("#")]),a._v(" 容器创建+启动")]),a._v(" "),r("p",[a._v("如果开发者需要既创建又启动容器，则可以使用 "),r("code",[a._v("docker run")]),a._v(" 命令。 "),r("code",[a._v("docker run")]),a._v(" 命令又可以启动两种不同模式的容器：\b后台型容器和交互型容器，\b顾名思义，\b后台型容器就是一个在后台运行的容器，默默的在后台执行计算就行了，不需要和开发者进行交互，而交互型容器则\b需要接收开发者的输入进行处理给出反馈。对于开发者而言，大部分情况下创建的都是后台型容器，不过在很多时候，即使是后台型容器也不可避免的需要进行交互，\b下面分别来看。")]),a._v(" "),r("h4",{attrs:{id:"后台型容器"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#后台型容器"}},[a._v("#")]),a._v(" \b后台型容器")]),a._v(" "),r("p",[a._v("后台型容器以 nginx 为例，一般 nginx 在后台运行即可：")]),a._v(" "),r("div",{staticClass:"language- extra-class"},[r("pre",{pre:!0,attrs:{class:"language-text"}},[r("code",[a._v("docker run --name nginx1 -d -p 8080:80 nginx\n")])])]),r("p",[r("code",[a._v("--name")]),a._v(" 含义和上文一样，表示创建的容器的名字，-d 表示容器在后台运行，-p 表示将容器的 80 端口映射到宿主机的 8080 端口，\b创建过程如下图：")]),a._v(" "),r("p",[r("img",{attrs:{src:"http://www.javaboy.org/images/docker/2-7.png",alt:"2-7"}})]),a._v(" "),r("p",[a._v("首先依然会去本地检查，本地\b没有相应的容器，则会去 Docker Hub 上查找，\b查找到了下载并运行，并且生成了一个容器 id。运行成功后，在浏览器中输入 "),r("code",[a._v("http://localhost:8080")]),a._v(" 就能看到 Nginx 的默认页面了，如下：")]),a._v(" "),r("p",[r("img",{attrs:{src:"http://www.javaboy.org/images/docker/2-8.png",alt:"2-8"}})]),a._v(" "),r("p",[a._v("这是一个后台型容器的基本创建方式。")]),a._v(" "),r("h4",{attrs:{id:"交互型容器"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#交互型容器"}},[a._v("#")]),a._v(" 交互型\b容器")]),a._v(" "),r("p",[a._v("也可以创建交互型容器，例如创建一个 ubuntu 容器，开发者可能需要在 ubuntu 上面输入\b命令执行相关操作，\b交互型\b容器创建方式如下：")]),a._v(" "),r("div",{staticClass:"language- extra-class"},[r("pre",{pre:!0,attrs:{class:"language-text"}},[r("code",[a._v("docker run --name ubuntu -it ubuntu /bin/bash\n")])])]),r("p",[a._v("参数含义都和上文一致，除了 -it，-it\b 参数，i 表示开发容器的标准输入（STDIN），t 则表示告诉 \bdocker，为容器创建一个\b命令行终端。执行结果如下：")]),a._v(" "),r("p",[r("img",{attrs:{src:"http://www.javaboy.org/images/docker/2-9.png",alt:"2-9"}})]),a._v(" "),r("p",[a._v("该命令执行完后，会打开一个输入终端，读者就可以在这个终端里愉快的操作 ubuntu 了。")]),a._v(" "),r("p",[a._v("想要退出该终端，只需要输入 exit 命令即可。")]),a._v(" "),r("h2",{attrs:{id:"容器启动"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#容器启动"}},[a._v("#")]),a._v(" 容器启动")]),a._v(" "),r("h3",{attrs:{id:"启动"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#启动"}},[a._v("#")]),a._v(" 启动")]),a._v(" "),r("p",[a._v("如果开发者使用了 "),r("code",[a._v("docker run")]),a._v(" 命令创建了容器，则创建完成后容器就已经启动了，如果使用了 "),r("code",[a._v("docker create")]),a._v(" 命令创建了容器，则需要再执行 "),r("code",[a._v("docker start")]),a._v(" 命令来启动容器，使用 "),r("code",[a._v("docker start")]),a._v(" 命令结合容器 id 或者容器 name 可以启动一个容器，如下：")]),a._v(" "),r("p",[r("img",{attrs:{src:"http://www.javaboy.org/images/docker/3-1.png",alt:"3-1"}})]),a._v(" "),r("p",[r("code",[a._v("docker start")]),a._v(" 启动的是一个已经存在的容器，要使用该命令启动一个容器，必须要先知道容器的 id 或者 name ，\b开发者可以通过这两个属性启动一个容器（案例中，nginx 是通过 name 启动，而 ubuntu 则是通过 id 启动）。一般来说，第一次可以使用 "),r("code",[a._v("docker run")]),a._v(" 启动一个容器，以后直接使用 "),r("code",[a._v("docker start")]),a._v(" 即可。")]),a._v(" "),r("h3",{attrs:{id:"重启"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#重启"}},[a._v("#")]),a._v(" 重启")]),a._v(" "),r("p",[a._v("容器在\b\b运行过程中，会不可避免的出问题，出了问题时，需要能够自动重启，在容器启动时使用\b --restart 参数可以实现这一需求。根据 docker 官网的解释，docker 的重启策略可以分为 4 种，如下：")]),a._v(" "),r("p",[r("img",{attrs:{src:"http://www.javaboy.org/images/docker/3-2.png",alt:"3-2"}})]),a._v(" "),r("p",[a._v("四种的含义分别如下：")]),a._v(" "),r("ol",[r("li",[a._v("no表示不自动重启容器，默认即此。")]),a._v(" "),r("li",[a._v("on:failure:[max-retries]表示在退出\b状态为非0时才会重启（非正常退出），有一个可选择参数：最大重启次数，可以设置\b最大重启次数，重启次数达到上限后就会放弃重启。")]),a._v(" "),r("li",[a._v("always表示始终重启容器，当docker守护进程启动时，也会\b无论容器当时的状态为何，都会尝试重启\b容器。")]),a._v(" "),r("li",[a._v("unless-stopped表示始终重启容器，但是当docker守护进程启动时，如果\b容器已经停止运行，则不会去重启它。")])]),a._v(" "),r("h2",{attrs:{id:"容器停止"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#容器停止"}},[a._v("#")]),a._v(" 容器停止")]),a._v(" "),r("p",[a._v("通过\b "),r("code",[a._v("docker stop")]),a._v(" 命令可以终止一个容器，如下：")]),a._v(" "),r("p",[r("img",{attrs:{src:"http://www.javaboy.org/images/docker/3-3.png",alt:"3-3"}})]),a._v(" "),r("p",[a._v("可以通过 name 或者 id 终止一个容器。")]),a._v(" "),r("h2",{attrs:{id:"容器删除"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#容器删除"}},[a._v("#")]),a._v(" 容器删除")]),a._v(" "),r("h3",{attrs:{id:"单个删除"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#单个删除"}},[a._v("#")]),a._v(" 单个删除")]),a._v(" "),r("p",[a._v("容器停止\b后还依然存在，如果需要\b，还可以通过 "),r("code",[a._v("docker start")]),a._v(" 命令再次重启一个容器，\b\b如果不需要一个容器，则可以通过 "),r("code",[a._v("docker rm")]),a._v(" 命令删除一个容器。删除容器时，只能删除已经停止运行的容器，不能删除正在运行的容器。如下：")]),a._v(" "),r("p",[r("img",{attrs:{src:"http://www.javaboy.org/images/docker/3-4.png",alt:"3-4"}})]),a._v(" "),r("p",[a._v("可以通过 name 或者 id 删除一个容器。如果非要删除一个\b正在运行的容器，可以通过 -f 参数实现，如下：")]),a._v(" "),r("p",[r("img",{attrs:{src:"http://www.javaboy.org/images/docker/3-5.png",alt:"3-5"}})]),a._v(" "),r("h3",{attrs:{id:"批量删除"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#批量删除"}},[a._v("#")]),a._v(" 批量删除")]),a._v(" "),r("p",[a._v("容器也可以批量删除，命令如下：")]),a._v(" "),r("div",{staticClass:"language- extra-class"},[r("pre",{pre:!0,attrs:{class:"language-text"}},[r("code",[a._v("docker rm $(docker ps -a -q)\n")])])]),r("p",[r("code",[a._v("docker ps -a -q")]),a._v(" 会列出所有容器的 id ，供 rm 命令删除。")]),a._v(" "),r("p",[a._v("如下命令也\b\b支持删除已退出的孤立的容器：")]),a._v(" "),r("div",{staticClass:"language- extra-class"},[r("pre",{pre:!0,attrs:{class:"language-text"}},[r("code",[a._v("docker container prune\n")])])]),r("h2",{attrs:{id:"总结"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#总结"}},[a._v("#")]),a._v(" 总结")]),a._v(" "),r("p",[a._v("本文主要向大家介绍了 Docker 容器的基本操作，更多高级操作我们将在下篇文章中介绍。")]),a._v(" "),r("p",[a._v("参考资料：")]),a._v(" "),r("p",[a._v("[1] 曾金龙，肖新华，刘清.Docker开发实践[M].北京：人民邮电出版社，2015.")])])}),[],!1,null,null,null);t.default=e.exports}}]);