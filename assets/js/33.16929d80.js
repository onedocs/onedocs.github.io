(window.webpackJsonp=window.webpackJsonp||[]).push([[33],{400:function(s,t,a){"use strict";a.r(t);var r=a(42),e=Object(r.a)({},(function(){var s=this,t=s.$createElement,a=s._self._c||t;return a("ContentSlotsDistributor",{attrs:{"slot-key":s.$parent.slotKey}},[a("p",[s._v("关于 MongoDB 中的查询，我们已经连着介绍了两篇文章了，本文我们来介绍另外一个查询概念"),a("strong",[s._v("游标")]),s._v("。")]),s._v(" "),a("h2",{attrs:{id:"基本操作"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#基本操作"}},[s._v("#")]),s._v(" 基本操作")]),s._v(" "),a("p",[s._v("游标这个概念在很多地方都有，Java 中 JDBC 里的 ResultSet ，Android 中的 Cursor 等等都是，MongoDB 中也有类似的概念。当我们调用 find 方法时，就可以返回一个游标，如下：")]),s._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[s._v("var cursor = db.sang_collect.find();\n")])])]),a("p",[s._v("游标中有 hasNext() 方法，也有 next() 方法，这两个方法结合可以用来遍历结果，如下：")]),s._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[s._v("while(cursor.hasNext()){\n    print(cursor.next())\n}\n")])])]),a("p",[s._v("next() 方法可以获取查询到的每一个文档，如下：")]),s._v(" "),a("div",{staticClass:"language-json extra-class"},[a("pre",{pre:!0,attrs:{class:"language-json"}},[a("code",[a("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v("{")]),s._v("\n    "),a("span",{pre:!0,attrs:{class:"token property"}},[s._v('"_id"')]),s._v(" "),a("span",{pre:!0,attrs:{class:"token operator"}},[s._v(":")]),s._v(" ObjectId("),a("span",{pre:!0,attrs:{class:"token string"}},[s._v('"59f299579babb96c21ddc9e8"')]),s._v(")"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(",")]),s._v("\n    "),a("span",{pre:!0,attrs:{class:"token property"}},[s._v('"x"')]),s._v(" "),a("span",{pre:!0,attrs:{class:"token operator"}},[s._v(":")]),s._v(" "),a("span",{pre:!0,attrs:{class:"token number"}},[s._v("0.0")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(",")]),s._v("\n    "),a("span",{pre:!0,attrs:{class:"token property"}},[s._v('"y"')]),s._v(" "),a("span",{pre:!0,attrs:{class:"token operator"}},[s._v(":")]),s._v(" "),a("span",{pre:!0,attrs:{class:"token number"}},[s._v("1000.0")]),s._v("\n"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v("}")]),s._v("\n\n"),a("span",{pre:!0,attrs:{class:"token comment"}},[s._v("/* 2 */")]),s._v("\n"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v("{")]),s._v("\n    "),a("span",{pre:!0,attrs:{class:"token property"}},[s._v('"_id"')]),s._v(" "),a("span",{pre:!0,attrs:{class:"token operator"}},[s._v(":")]),s._v(" ObjectId("),a("span",{pre:!0,attrs:{class:"token string"}},[s._v('"59f299579babb96c21ddc9e9"')]),s._v(")"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(",")]),s._v("\n    "),a("span",{pre:!0,attrs:{class:"token property"}},[s._v('"x"')]),s._v(" "),a("span",{pre:!0,attrs:{class:"token operator"}},[s._v(":")]),s._v(" "),a("span",{pre:!0,attrs:{class:"token number"}},[s._v("1.0")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(",")]),s._v("\n    "),a("span",{pre:!0,attrs:{class:"token property"}},[s._v('"y"')]),s._v(" "),a("span",{pre:!0,attrs:{class:"token operator"}},[s._v(":")]),s._v(" "),a("span",{pre:!0,attrs:{class:"token number"}},[s._v("999.0")]),s._v("\n"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v("}")]),s._v("\n")])])]),a("p",[s._v("如果我只想获取文档中的某一个字段，可以按如下方式：")]),s._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[s._v("while(cursor.hasNext()){\n    print(cursor.next().y)\n}\n")])])]),a("p",[s._v("cursor 也实现了 JavaScript 中的迭代器接口，所以我们也可以直接调用 forEach 方法来遍历：")]),s._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[s._v("cursor.forEach(function(x){\n    print(x)\n    })\n")])])]),a("p",[s._v("当我们调用 find 方法获取 cursor 时，shell 并不会立即查询数据库，而是在真正使用数据时才会去加载，这有点类似于数据库框架中的懒加载，shell 在每次查询的时候会获取前 100 条结果或者前 4MB 数据(两者之间取最小)，然后我们调用 hasNext 和 next 时 shell 就不用再去连接数据库了，直接一条一条的返回查询到的数据，这 100 条或者 4MB 数据全部被返回之后，shell 才会再次发起请求向 MongoDB 要数据。")]),s._v(" "),a("h2",{attrs:{id:"limit"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#limit"}},[s._v("#")]),s._v(" limit")]),s._v(" "),a("p",[s._v("limit 是 cursor 中的方法，用来限制返回结果的数量，比如我只想获取查询的前三条结果，方式如下：")]),s._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[s._v("var cursor = db.sang_collect.find().limit(3)\n")])])]),a("h2",{attrs:{id:"skip"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#skip"}},[s._v("#")]),s._v(" skip")]),s._v(" "),a("p",[s._v("skip 也是 cursor 中的方法，用来表示跳过的记录数，比如我想获取第2到第5条记录，如下：")]),s._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[s._v("var cursor = db.sang_collect.find().skip(2).limit(4)\n")])])]),a("p",[s._v("跳过前两条( 0 和 1 )然后获取后面 4 条数据，skip 和 limit 结合有点类似于 MySQL 中的 limit，可以用来做分页，不过这种分页方式效率过低。")]),s._v(" "),a("h2",{attrs:{id:"sort"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#sort"}},[s._v("#")]),s._v(" sort")]),s._v(" "),a("p",[s._v("sort 用来实现排序功能，比如按 x 排序，如下：")]),s._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[s._v("var cursor = db.sang_collect.find().sort({x:-1})\n")])])]),a("p",[s._v("1 表示升序，-1 表示降序。")]),s._v(" "),a("p",[s._v("好了，MongoDB 中的查询我们就说到这里，小伙伴们有问题欢迎留言讨论。")]),s._v(" "),a("p",[s._v("参考资料：")]),s._v(" "),a("ol",[a("li",[s._v("《MongoDB权威指南第2版》")])])])}),[],!1,null,null,null);t.default=e.exports}}]);